# CapitalSure - Cline.bot Development Rules

**Universal Construction OS Development Standards**

*Version: 1.0*  
*Last Updated: June 9, 2025*  
*Project: CapitalSure (Universal Construction OS)*

---

## Project Overview

You are building **CapitalSure**, a universal construction operating system designed to create accountability, schedule certainty, and capital protection for construction projects. The platform serves owners, developers, general contractors, subcontractors, and lenders through AI-powered scheduling, escrow-backed payments, and immutable progress tracking.

### Core Technology Stack
- **Frontend Web**: Next.js 14+ with App Router, TypeScript, Tailwind CSS
- **Frontend Mobile**: React Native with Expo Router
- **Backend**: Supabase (PostgreSQL, Auth, Real-time, Storage)
- **Deployment**: Vercel (web), Expo Application Services (mobile)
- **UI Components**: shadcn/ui with Radix UI primitives
- **State Management**: Zustand + React Query (TanStack Query)

### Key Personas
1. **Owner/Developer/Lender** - Financial certainty and risk mitigation
2. **General Contractor** - Project management and subcontractor coordination  
3. **Site Superintendent/Foreman** - Daily field operations and progress tracking
4. **Subcontractor** - Job booking and payment assurance
5. **Lender/Surety** - Compliance and verification

---

## Core Development Standards

### TypeScript Configuration
Always use strict TypeScript configuration with the following settings:

```json
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitOverride": true,
    "exactOptionalPropertyTypes": true
  }
}
```

### File and Folder Naming
- Use kebab-case for files and folders: `schedule-board.tsx`, `daily-progress-log.tsx`
- Use PascalCase for React components: `ScheduleBoard`, `DailyProgressLog`
- Use camelCase for functions and variables: `calculateScheduleHealth`, `progressData`
- Use SCREAMING_SNAKE_CASE for constants: `MAX_UPLOAD_SIZE`, `DEFAULT_TIMEOUT`

### Component Organization
```
src/
├── app/                    # Next.js App Router pages
├── components/
│   ├── ui/                # shadcn/ui components
│   ├── forms/             # Form components
│   ├── charts/            # Data visualization
│   └── construction/      # Domain-specific components
├── lib/
│   ├── supabase/          # Database utilities
│   ├── utils/             # Helper functions
│   └── validations/       # Zod schemas
├── hooks/                 # Custom React hooks
├── stores/                # Zustand stores
└── types/                 # TypeScript type definitions
```

### Error Handling Standards
Always implement comprehensive error handling:

```typescript
// Use Result pattern for operations that can fail
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E }

// Example usage
async function createProject(data: ProjectData): Promise<Result<Project>> {
  try {
    const project = await supabase
      .from('projects')
      .insert(data)
      .select()
      .single()
    
    if (project.error) {
      return { success: false, error: new Error(project.error.message) }
    }
    
    return { success: true, data: project.data }
  } catch (error) {
    return { success: false, error: error as Error }
  }
}
```

### Data Validation
Use Zod for all data validation with construction-specific schemas:

```typescript
import { z } from 'zod'

export const ProjectSchema = z.object({
  name: z.string().min(1, 'Project name is required'),
  type: z.enum(['residential', 'commercial']),
  budget: z.number().positive('Budget must be positive'),
  startDate: z.date(),
  estimatedEndDate: z.date(),
  address: z.object({
    street: z.string(),
    city: z.string(),
    state: z.string(),
    zipCode: z.string().regex(/^\d{5}(-\d{4})?$/, 'Invalid ZIP code')
  })
})

export type Project = z.infer<typeof ProjectSchema>
```

---

## Next.js Specific Rules

### App Router Structure
Use the new App Router with proper layout hierarchy:

```
app/
├── layout.tsx             # Root layout
├── page.tsx              # Home page
├── (auth)/               # Route groups
│   ├── login/
│   └── register/
├── dashboard/
│   ├── layout.tsx        # Dashboard layout
│   ├── page.tsx          # Dashboard home
│   ├── projects/
│   ├── schedule/
│   └── analytics/
└── api/                  # API routes
    ├── projects/
    ├── tasks/
    └── webhooks/
```

### Server Components and Client Components
- Use Server Components by default for better performance
- Only use 'use client' when necessary (interactivity, hooks, browser APIs)
- Clearly separate server and client logic

```typescript
// Server Component (default)
export default async function ProjectsPage() {
  const projects = await getProjects() // Server-side data fetching
  
  return (
    <div>
      <ProjectsList projects={projects} />
      <CreateProjectButton /> {/* Client component for interactivity */}
    </div>
  )
}

// Client Component
'use client'
export function CreateProjectButton() {
  const [isOpen, setIsOpen] = useState(false)
  // Client-side interactivity
}
```

### API Routes and Server Actions
Prefer Server Actions for mutations, API routes for external integrations:

```typescript
// Server Action (preferred for forms)
'use server'
export async function createProject(formData: FormData) {
  const validatedData = ProjectSchema.parse({
    name: formData.get('name'),
    type: formData.get('type'),
    // ... other fields
  })
  
  const result = await supabase
    .from('projects')
    .insert(validatedData)
  
  if (result.error) {
    throw new Error(result.error.message)
  }
  
  revalidatePath('/dashboard/projects')
  redirect('/dashboard/projects')
}

// API Route (for webhooks, external APIs)
export async function POST(request: Request) {
  const body = await request.json()
  // Handle external webhook
  return Response.json({ success: true })
}
```

### Performance Optimization
- Use dynamic imports for heavy components
- Implement proper loading states
- Optimize images with Next.js Image component
- Use Suspense boundaries for better UX

```typescript
import { Suspense } from 'react'
import dynamic from 'next/dynamic'

// Dynamic import for heavy components
const ScheduleChart = dynamic(() => import('./schedule-chart'), {
  loading: () => <ChartSkeleton />,
  ssr: false // If component uses browser-only APIs
})

// Suspense boundaries
export default function DashboardPage() {
  return (
    <div>
      <Suspense fallback={<ProjectsSkeleton />}>
        <ProjectsList />
      </Suspense>
      <Suspense fallback={<ChartSkeleton />}>
        <ScheduleChart />
      </Suspense>
    </div>
  )
}
```

---

## Supabase Integration Rules

### Database Schema Conventions
Follow these naming and structure conventions:

```sql
-- Table naming: snake_case, plural
CREATE TABLE projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  type project_type NOT NULL,
  budget DECIMAL(12,2),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Foreign key naming: {table}_id
CREATE TABLE tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  status task_status DEFAULT 'pending'
);

-- Junction tables: {table1}_{table2}
CREATE TABLE project_users (
  project_id UUID REFERENCES projects(id),
  user_id UUID REFERENCES auth.users(id),
  role user_role NOT NULL,
  PRIMARY KEY (project_id, user_id)
);
```

### Row Level Security (RLS)
Always implement RLS for data security:

```sql
-- Enable RLS
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;

-- Users can only see projects they're assigned to
CREATE POLICY "Users can view assigned projects" ON projects
  FOR SELECT USING (
    id IN (
      SELECT project_id FROM project_users 
      WHERE user_id = auth.uid()
    )
  );

-- Only project managers can create projects
CREATE POLICY "Project managers can create projects" ON projects
  FOR INSERT WITH CHECK (
    auth.jwt() ->> 'role' = 'project_manager'
  );
```

### Type-Safe Database Queries
Generate and use TypeScript types from Supabase:

```typescript
// Generate types: npx supabase gen types typescript --local > types/database.ts
import { Database } from '@/types/database'

export type Project = Database['public']['Tables']['projects']['Row']
export type ProjectInsert = Database['public']['Tables']['projects']['Insert']
export type ProjectUpdate = Database['public']['Tables']['projects']['Update']

// Type-safe queries
const { data: projects, error } = await supabase
  .from('projects')
  .select(`
    *,
    tasks (
      id,
      name,
      status
    )
  `)
  .eq('type', 'residential')
```

### Real-time Subscriptions
Implement real-time updates for collaborative features:

```typescript
'use client'
export function useProjectUpdates(projectId: string) {
  const [project, setProject] = useState<Project | null>(null)
  
  useEffect(() => {
    const channel = supabase
      .channel(`project-${projectId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'projects',
          filter: `id=eq.${projectId}`
        },
        (payload) => {
          if (payload.eventType === 'UPDATE') {
            setProject(payload.new as Project)
          }
        }
      )
      .subscribe()
    
    return () => {
      supabase.removeChannel(channel)
    }
  }, [projectId])
  
  return project
}
```

### File Storage
Handle construction documents and photos:

```typescript
export async function uploadProjectPhoto(
  projectId: string,
  file: File,
  category: 'progress' | 'issue' | 'completion'
) {
  const fileExt = file.name.split('.').pop()
  const fileName = `${projectId}/${category}/${Date.now()}.${fileExt}`
  
  const { data, error } = await supabase.storage
    .from('project-photos')
    .upload(fileName, file, {
      cacheControl: '3600',
      upsert: false
    })
  
  if (error) throw error
  
  // Get public URL
  const { data: { publicUrl } } = supabase.storage
    .from('project-photos')
    .getPublicUrl(fileName)
  
  return publicUrl
}
```

---

## Mobile Responsiveness Rules

### Responsive Design Principles
Design mobile-first with progressive enhancement:

```css
/* Mobile-first approach */
.schedule-board {
  @apply grid grid-cols-1 gap-4;
}

/* Tablet */
@media (min-width: 768px) {
  .schedule-board {
    @apply grid-cols-2;
  }
}

/* Desktop */
@media (min-width: 1024px) {
  .schedule-board {
    @apply grid-cols-3;
  }
}

/* Large screens */
@media (min-width: 1440px) {
  .schedule-board {
    @apply max-w-7xl mx-auto;
  }
}
```

### Touch-Friendly Interface
Design for field workers wearing gloves:

```typescript
// Large touch targets (minimum 44px)
const TouchButton = ({ children, ...props }: ButtonProps) => (
  <button
    className="min-h-[44px] min-w-[44px] px-4 py-3 text-lg"
    {...props}
  >
    {children}
  </button>
)

// Swipe gestures for mobile navigation
export function useSwipeNavigation() {
  const [touchStart, setTouchStart] = useState<number | null>(null)
  const [touchEnd, setTouchEnd] = useState<number | null>(null)
  
  const minSwipeDistance = 50
  
  const onTouchStart = (e: TouchEvent) => {
    setTouchEnd(null)
    setTouchStart(e.targetTouches[0].clientX)
  }
  
  const onTouchMove = (e: TouchEvent) => {
    setTouchEnd(e.targetTouches[0].clientX)
  }
  
  const onTouchEnd = () => {
    if (!touchStart || !touchEnd) return
    
    const distance = touchStart - touchEnd
    const isLeftSwipe = distance > minSwipeDistance
    const isRightSwipe = distance < -minSwipeDistance
    
    if (isLeftSwipe) {
      // Navigate to next
    }
    if (isRightSwipe) {
      // Navigate to previous
    }
  }
  
  return { onTouchStart, onTouchMove, onTouchEnd }
}
```

### Offline Functionality
Essential for construction sites with poor connectivity:

```typescript
// Service Worker for offline caching
export function registerServiceWorker() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js')
  }
}

// Offline data synchronization
export function useOfflineSync() {
  const [isOnline, setIsOnline] = useState(navigator.onLine)
  const [pendingActions, setPendingActions] = useState<Action[]>([])
  
  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true)
      // Sync pending actions
      syncPendingActions()
    }
    
    const handleOffline = () => setIsOnline(false)
    
    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)
    
    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])
  
  const syncPendingActions = async () => {
    for (const action of pendingActions) {
      try {
        await executeAction(action)
        setPendingActions(prev => prev.filter(a => a.id !== action.id))
      } catch (error) {
        console.error('Failed to sync action:', error)
      }
    }
  }
  
  return { isOnline, pendingActions, addPendingAction: setPendingActions }
}
```

### Progressive Web App (PWA)
Make the web app installable on mobile devices:

```typescript
// manifest.json
{
  "name": "CapitalSure",
  "short_name": "CapitalSure",
  "description": "Universal Construction Operating System",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#2563eb",
  "icons": [
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}

// PWA install prompt
export function usePWAInstall() {
  const [deferredPrompt, setDeferredPrompt] = useState<any>(null)
  const [isInstallable, setIsInstallable] = useState(false)
  
  useEffect(() => {
    const handler = (e: Event) => {
      e.preventDefault()
      setDeferredPrompt(e)
      setIsInstallable(true)
    }
    
    window.addEventListener('beforeinstallprompt', handler)
    
    return () => window.removeEventListener('beforeinstallprompt', handler)
  }, [])
  
  const installPWA = async () => {
    if (!deferredPrompt) return
    
    deferredPrompt.prompt()
    const { outcome } = await deferredPrompt.userChoice
    
    if (outcome === 'accepted') {
      setIsInstallable(false)
      setDeferredPrompt(null)
    }
  }
  
  return { isInstallable, installPWA }
}
```

---

This comprehensive rule set ensures CapitalSure is built with construction industry best practices, modern web standards, and optimal user experience for all stakeholders in the construction process.

